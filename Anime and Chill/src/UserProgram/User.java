package UserProgram;

import java.io.IOException;
import java.sql.SQLException;

import DataAlloc.DataManipulate;
import Graphs.ShortPath;

public class User {

	private String username; // User name
	private Integer[] animeList; // List of ANIMES watched by user
	private int[] eps; // List of episodes watched per ANIME corresponding to animeList
	private double[] scores; // List of scores given by user per ANIME corresponding to animeList

	private User[] friends = new User[200]; // Users accepted friends

	private int friendCount = 0; // Keeps tracks of how many friends are in "friends

	private User[] potMat = new User[1000]; // Randomly filled potential mates
	private int potMatCount = 0;

	private int location;

	public User(String username, Integer[] animeList, int[] eps, double[] scores, int location) {
		this.username = username;
		this.animeList = animeList;
		this.eps = eps;
		this.scores = scores;
		this.location = location;
	}

	/* ***************************************************** */
	/* ***************** FUNCTION METHODS ********************* */
	/* ***************************************************** */

	public void swipe(boolean verdict) {

		if (verdict) {
			this.friends[this.friendCount] = this.potMat[this.potMatCount];

			this.friendCount++;
			this.potMatCount++;
		}

		else {
			this.potMatCount++;
		}
	}

	public void fillPotentialTest(User[] users) {
		for (int i = 0; i < users.length; i++) {
			this.potMat[i] = users[i];
		}
	}

	public void fillPotential() throws SQLException, IOException {

		this.potMatCount = 0;

		for (int i = 0; i < this.potMat.length; i++) {

			String userNameRet = DataManipulate.random_data();

			String[] animeListStr = DataManipulate.retrieve_data(userNameRet, "animeID").split(" ");
			Integer[] animeList = new Integer[animeListStr.length];

			for (int j = 0; j < animeList.length; j++) {
				animeList[j] = Integer.parseInt(animeListStr[j]);
			}

			String[] epsStr = DataManipulate.retrieve_data(userNameRet, "episodes").split(" ");
			int[] eps = new int[epsStr.length];

			for (int j = 0; j < eps.length; j++) {
				eps[j] = Integer.parseInt(epsStr[j]);
			}

			String[] scoresStr = DataManipulate.retrieve_data(userNameRet, "episodes").split(" ");
			double[] scores = new double[scoresStr.length];

			for (int j = 0; j < scores.length; j++) {
				scores[j] = Integer.parseInt(scoresStr[j]);
			}

			int location = Integer.parseInt(DataManipulate.retrieve_data(userNameRet, "location"));

			this.potMat[i] = new User(userNameRet, animeList, eps, scores, location);
		}
		sortPotMat();
	}

	private double compareUser(User that) throws IOException{

		double totalDifference = 0.0;
		Integer[] thatAnimeList = that.getAnimeList();
		double[] thatScores = that.getScores();
		int count = 0;

		for (int i = 0; i < this.animeList.length; i++) {
			for (int j = 0; j < thatAnimeList.length; j++) {
				if (this.animeList[i] == thatAnimeList[j]) {
					//this computes the compatability score between the user and another user
					totalDifference += Math.abs((this.scores[i] - thatScores[j]));
					count++;
				}
			}
		}
		
		double compate = totalDifference / count + ShortPath.path(this.getLocation(), that.getLocation());
		
		return Math.abs(totalDifference);
	}

	private void sortPotMat() throws IOException{

		// Trying to sort potMat by the scores received by compareUser

		for (int i = 1; i < this.potMat.length; i++) {
			for (int j = i; j > 0; j--) {
				if (this.compareUser(this.potMat[j]) < this.compareUser(this.potMat[j - 1])) {
					User temp = this.potMat[j];
					this.potMat[j] = this.potMat[j - 1];
					this.potMat[j - 1] = temp;
				} else
					break;
			}
		}
	}

	/* ***************************************************** */
	/* ***************** ACCESSOR METHODS ****************** */
	/* ***************************************************** */

	public String getUser() {
		return this.username; // Returns user name
	}

	public User[] getFriends() {
		return this.friends; // Returns friends list
	}

	public int getLocation() {
		return this.location; // Returns location
	}

	public Integer[] getAnimeList() {
		return this.animeList; // Returns a list of watched animes (by anime IDS)
	}

	public int[] getEpisodes() {
		return this.eps;
	}

	public double[] getScores() {
		return this.scores; // Returns a list of scores corresponding to animes in anime list
	}

	public User getPotMatUser() {
		return this.potMat[this.potMatCount];
	}

	public User[] getPotMat() {
		return this.potMat; // Gets list of potential mate (generated by data base).
	}

	/* ***************************************************** */
	/* ***************** MAIN TEST METHODS ***************** */
	/* ***************************************************** */

	public static void main(String[] args) throws SQLException, IOException {

		Integer[] animeList1 = { 1, 2, 3, 4, 5 };
		int[] eps1 = { 4, 2, 7, 5, 6 };
		double[] scores1 = { 4.0, 2.0, 7.0, 2.0, 3.0 };

		User yo = new User("yo", animeList1, eps1, scores1, 12);

		yo.fillPotential();

		User[] hello = yo.getFriends();

		yo.swipe(true);

		for (int i = 0; i < hello.length; i++) {
			if (hello[i] != null)
				System.out.println(hello[i]);
		}

	}

}